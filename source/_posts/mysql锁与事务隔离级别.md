---
title: mysql锁与事务隔离级别
date: 2021-12-18 22:03:27
tags:
 - mysql锁
 - mysql事务隔离级别
categories: 性能调优
---

# 锁是什么？

* 锁是计算机协调多个线程或进程并发访问同一资源的机制。
* 在数据库中，数据是一种共享的资源，因此也需要保证数据并发访问的一致性和有效性。

# 锁的分类

- 从性能上来分为：`乐观锁`和`悲观锁`

  - 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。

  - 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。

    > 乐观锁一般通过版本比对的方式来实现的：
    >
    > - 当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。
    >
    > - 当我们提交更新的时候，判断数据库表对应记录的当前版本信息与我们第一次取出的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。那么更新操作就会失败。

- 从操作类型来分为：`读锁`和`写锁`

  - 读锁：也称为共享锁，多个读操作可以同时进行，且互不影响。
  - 写锁：也称为拍他锁，他可以阻断其他读操作或者写操作。

- 从可操作的粒度来分为：`表锁`和`行锁`
  - 表锁：每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲 

    突的概率最高，并发度最低；

  - 行锁：每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁 

    冲突的概率最低，并发度最高。

# mysql 事务

## 1.事务定义

事务是一个操作集合，这些操作要么都执行，要么都不执行，他是一个不可分割的工作单位。

## 2.事务的四大特性

- 原子性：事务是一个原子操作单元，它对数据的修改，要么都执行，要么都不执行。
- 一致性：一个事务执行前和执行后，数据必须保持一致，如：转账前用户AB的钱加在一起时500，转账后也应该是500
- 隔离型：事务外的实体不可以知道事务过程中的中间状态
- 持久性：对数据库的操作是永久性的，即使系统故障也能保持

## 3.不考虑事务的隔离性会产生并发问题

- 更新丢失：当两个或者多个事务同时对一行数据进行更新，会发生数据的覆盖，最后的更新覆盖了其他事务的更新。
- 脏读：读到了没有提交的数据，一个事务正在写操作，另一个事务进行了读操作，读到了脏数据。如果此时事务回滚，读取到的数据就是无效的。
- 不可重复读：读到了已经提交的数据，事务A多次读取同一数据，但在这个过程中，事务B对数据进行了修改并提交，会导致事务A多次读取数据结果不一致。
- 幻读：事务A读取到了事务B提交的新增数据。一个事务按照相同的查询条件查询之前检索过的数据，却发现插入了满足查询条件的新数据。

# mysql 事务隔离级别

## 1.读未提交

- 打开两个客户端：客户端A设置当前事务模式为read uncommitted，查询employees 表的初始值

  ```sql
  mysql> select @@transaction_isolation;
  +-------------------------+
  | @@transaction_isolation |
  +-------------------------+
  | READ-UNCOMMITTED        |
  +-------------------------+
  1 row in set (0.00 sec)
  
  mysql>  select * from employees;
  +----+-----------+-----+----------+---------------------+
  | id | name      | age | position | hire_time           |
  +----+-----------+-----+----------+---------------------+
  |  4 | LiLei     |  22 | mana ger | 2021-12-06 21:36:50 |
  |  5 | HanMeimei |  23 | dev      | 2021-12-06 21:36:50 |
  |  6 | Lucy      |  23 | dev      | 2021-12-06 21:36:50 |
  +----+-----------+-----+----------+---------------------+
  3 rows in set (0.00 sec)
  ```

- 客户端B开启事务，并执行更新操作

  ```sql
  mysql> begin;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql>  update employees set name = "newLiLei" where id = 4;
  Query OK, 1 row affected (0.00 sec)
  Rows matched: 1  Changed: 1  Warnings: 0
  ```

- 这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据，一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是**脏数据**： 

- ```sql
  mysql>  select * from employees;
  +----+-----------+-----+----------+---------------------+
  | id | name      | age | position | hire_time           |
  +----+-----------+-----+----------+---------------------+
  |  4 | newLiLei  |  22 | mana ger | 2021-12-06 21:36:50 |
  |  5 | HanMeimei |  23 | dev      | 2021-12-06 21:36:50 |
  |  6 | Lucy      |  23 | dev      | 2021-12-06 21:36:50 |
  +----+-----------+-----+----------+---------------------+
  3 rows in set (0.00 sec)
  ```

## 读已提交

- 打开两个客户端：客户端A设置当前事务模式为read committed，查询employees 表的初始值

```sql
mysql> select @@transaction_isolation;
+-------------------------+
| @@transaction_isolation |
+-------------------------+
| READ-COMMITTED          |
+-------------------------+
1 row in set (0.00 sec)

mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from employees;
+----+-----------+-----+----------+---------------------+
| id | name      | age | position | hire_time           |
+----+-----------+-----+----------+---------------------+
|  4 | LiLei     |  22 | mana ger | 2021-12-06 21:36:50 |
|  5 | HanMeimei |  23 | dev      | 2021-12-06 21:36:50 |
|  6 | Lucy      |  23 | dev      | 2021-12-06 21:36:50 |
+----+-----------+-----+----------+---------------------+
3 rows in set (0.00 sec)
```

- 客户端B开启事务，并执行更新操作

```sql
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql>  update employees set name = "newLiLei" where id = 4;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
```

- 这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，解决了脏读问题：

```sql
mysql> select * from employees;
+----+-----------+-----+----------+---------------------+
| id | name      | age | position | hire_time           |
+----+-----------+-----+----------+---------------------+
|  4 | LiLei     |  22 | mana ger | 2021-12-06 21:36:50 |
|  5 | HanMeimei |  23 | dev      | 2021-12-06 21:36:50 |
|  6 | Lucy      |  23 | dev      | 2021-12-06 21:36:50 |
+----+-----------+-----+----------+---------------------+
3 rows in set (0.00 sec)
```

- 客户端B的事务提交

```sql
mysql> commit;
Query OK, 0 rows affected (0.01 sec)
```

- 客户端A再次查询，结果 与上一步不一致，即产生了不可重复读的问题

```sql
mysql> select * from employees;
+----+-----------+-----+----------+---------------------+
| id | name      | age | position | hire_time           |
+----+-----------+-----+----------+---------------------+
|  4 | newLiLei  |  22 | mana ger | 2021-12-06 21:36:50 |
|  5 | HanMeimei |  23 | dev      | 2021-12-06 21:36:50 |
|  6 | Lucy      |  23 | dev      | 2021-12-06 21:36:50 |
+----+-----------+-----+----------+---------------------+
```



## 可重复读

- 打开两个客户端：客户端A设置当前事务模式为REPEATABLE-READ，查询employees 表的初始值

```sql
mysql> select @@transaction_isolation;
+-------------------------+
| @@transaction_isolation |
+-------------------------+
| REPEATABLE-READ         |
+-------------------------+
1 row in set (0.00 sec)

mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from employees;
+----+-----------+-----+----------+---------------------+
| id | name      | age | position | hire_time           |
+----+-----------+-----+----------+---------------------+
|  4 | LiLei     |  22 | mana ger | 2021-12-06 21:36:50 |
|  5 | HanMeimei |  23 | dev      | 2021-12-06 21:36:50 |
|  6 | Lucy      |  23 | dev      | 2021-12-06 21:36:50 |
+----+-----------+-----+----------+---------------------+
3 rows in set (0.00 sec)
```

- 客户端B开启事务，并执行更新操作, 并提交。

```sql
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql>  update employees set name = "newLiLei" where id = 4;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
```

- 在客户端A查询表account的所有记录，与上一次查询结果一致，没up有出现不可重复读的问题

```sql
mysql> select * from employees;
+----+-----------+-----+----------+---------------------+
| id | name      | age | position | hire_time           |
+----+-----------+-----+----------+---------------------+
|  4 | LiLei     |  22 | mana ger | 2021-12-06 21:36:50 |
|  5 | HanMeimei |  23 | dev      | 2021-12-06 21:36:50 |
|  6 | Lucy      |  23 | dev      | 2021-12-06 21:36:50 |
+----+-----------+-----+----------+---------------------+
3 rows in set (0.01 sec)
```

- 

# mysql事务隔离性的实现

## MVCC机制

* mysql在每行记录后面，保存了两个隐藏列，分别为：创建事务id和删除事务id

- 当执行select操作的时候，mysql底层会带上过滤条件：
  - 创建事务id <= max(当前事务id, 已提交的最大事务id)
  - 删除事务id  >  max (当前事务id, 已提交的最大事务id) 

 update employees set name = 'LiLei'  where id = 1;



# InnoDB与MYISAM的最大不同有两点：

1. 支持事务
2. 支持行锁
